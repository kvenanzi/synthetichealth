# HL7 ADT Messages Primer: Understanding Admit, Discharge, Transfer Messages

## Overview

HL7 ADT (Admit, Discharge, Transfer) messages are the backbone of patient administration communication in healthcare systems. This primer explains how to read, understand, and work with HL7 ADT messages generated by the Synthetic Healthcare Data Generator.

## Table of Contents

1. [What are HL7 ADT Messages?](#what-are-hl7-adt-messages)
2. [Message Structure](#message-structure)
3. [Common ADT Event Types](#common-adt-event-types)
4. [Segment Breakdown](#segment-breakdown)
5. [Field Separators and Encoding](#field-separators-and-encoding)
6. [Reading ADT Messages](#reading-adt-messages)
7. [Working with ADT Data](#working-with-adt-data)
8. [Tools and Libraries](#tools-and-libraries)
9. [Examples](#examples)

---

## What are HL7 ADT Messages?

**HL7 ADT (Admit, Discharge, Transfer)** messages communicate patient movement and demographic information between healthcare systems. They are part of the HL7 v2.x standard and handle:

- **Patient Registration** (A04, A05, A08)
- **Patient Admission** (A01, A02, A03)
- **Patient Transfer** (A02, A06, A07)
- **Patient Discharge** (A03, A13, A16)
- **Patient Updates** (A08, A31)

### Key Use Cases
- **Hospital ADT Systems**: Track patient movement within hospitals
- **EHR Integration**: Synchronize patient demographics across systems
- **Billing Systems**: Trigger billing processes based on admission/discharge
- **Clinical Systems**: Update patient location for clinical staff

---

## Message Structure

### Basic HL7 Message Format

HL7 messages are pipe-delimited text with a specific structure:

```
MSH|^~\&|SENDING_APP|SENDING_FACILITY|RECEIVING_APP|RECEIVING_FACILITY|TIMESTAMP||MSG_TYPE|CONTROL_ID|PROCESSING_ID|VERSION_ID
EVN||TIMESTAMP|||OPERATOR_ID
PID|1||MRN^^^FACILITY^MR~SSN^^^USA^SS||LAST^FIRST^MIDDLE||DOB|SEX|||ADDRESS^^CITY^STATE^ZIP||PHONE||LANGUAGE|MARITAL||ACCOUNT|||RACE^ETHNICITY
PV1|1|PATIENT_CLASS|LOCATION|||ADMISSION_TYPE|||ATTENDING|||SERVICE||ADMISSION_SOURCE|ADMISSION_DATE
```

### Message Components
- **MSH**: Message Header (required in all messages)
- **EVN**: Event Type (required for ADT messages)
- **PID**: Patient Identification (required)
- **PV1**: Patient Visit (required for most ADT events)
- **Additional segments**: PV2, OBX, AL1, etc. (optional)

---

## Common ADT Event Types

### Primary ADT Events

| Event Code | Description | When Used |
|------------|-------------|-----------|
| **A01** | Admit/Visit Notification | Patient admitted to hospital |
| **A02** | Transfer a Patient | Patient transferred to different unit/room |
| **A03** | Discharge/End Visit | Patient discharged from hospital |
| **A04** | Register a Patient | Outpatient registration or pre-admission |
| **A05** | Pre-admit a Patient | Pre-registration before admission |
| **A06** | Change Outpatient to Inpatient | Status change from outpatient to inpatient |
| **A07** | Change Inpatient to Outpatient | Status change from inpatient to outpatient |
| **A08** | Update Patient Information | Demographics or visit information update |

### Secondary Events

| Event Code | Description | Usage |
|------------|-------------|--------|
| **A11** | Cancel Admit/Visit | Cancel a previously sent admission |
| **A12** | Cancel Transfer | Cancel a previously sent transfer |
| **A13** | Cancel Discharge | Cancel a previously sent discharge |
| **A31** | Update Person Information | Update demographics only |

---

## Segment Breakdown

### MSH - Message Header Segment

```
MSH|^~\&|VistA|VA_FACILITY|Oracle|ORACLE_FACILITY|20231215120000||ADT^A04|MSG001|P|2.5
```

**Field Breakdown:**
- **MSH.1**: Field separator (`|`)
- **MSH.2**: Encoding characters (`^~\&`)
- **MSH.3**: Sending application (`VistA`)
- **MSH.4**: Sending facility (`VA_FACILITY`)
- **MSH.5**: Receiving application (`Oracle`)
- **MSH.6**: Receiving facility (`ORACLE_FACILITY`)
- **MSH.7**: Date/time of message (`20231215120000`)
- **MSH.8**: Security (usually empty)
- **MSH.9**: Message type (`ADT^A04`)
- **MSH.10**: Message control ID (`MSG001`)
- **MSH.11**: Processing ID (`P` = Production)
- **MSH.12**: Version ID (`2.5`)

### EVN - Event Type Segment

```
EVN||20231215120000|||OPERATOR123
```

**Field Breakdown:**
- **EVN.1**: Event Type Code (usually empty in ADT)
- **EVN.2**: Recorded Date/Time (`20231215120000`)
- **EVN.3**: Date/Time Planned Event (optional)
- **EVN.4**: Event Reason Code (optional)
- **EVN.5**: Operator ID (`OPERATOR123`)

### PID - Patient Identification Segment

```
PID|1||MRN123456^^^VA^MR~123456789^^^USA^SS||DOE^JOHN^MICHAEL||19800115|M|||123 MAIN ST^^ANYTOWN^VA^12345||555-123-4567||EN|M||ACC123456|||W^White^HL70005
```

**Field Breakdown:**
- **PID.1**: Set ID (`1`)
- **PID.2**: Patient ID (external, usually empty)
- **PID.3**: Patient identifier list (`MRN123456^^^VA^MR~123456789^^^USA^SS`)
  - Multiple identifiers separated by `~`
  - Format: `ID^^^AUTHORITY^ID_TYPE`
- **PID.4**: Alternate patient ID (usually empty)
- **PID.5**: Patient name (`DOE^JOHN^MICHAEL`)
  - Format: `LAST^FIRST^MIDDLE`
- **PID.6**: Mother's maiden name (usually empty)
- **PID.7**: Date/time of birth (`19800115`)
- **PID.8**: Administrative sex (`M`)
- **PID.9**: Patient alias (usually empty)
- **PID.10**: Race (`W^White^HL70005`)
- **PID.11**: Patient address (`123 MAIN ST^^ANYTOWN^VA^12345`)
- **PID.12**: County code (usually empty)
- **PID.13**: Phone number - home (`555-123-4567`)
- **PID.14**: Phone number - business (usually empty)
- **PID.15**: Primary language (`EN`)
- **PID.16**: Marital status (`M`)
- **PID.17**: Religion (usually empty)
- **PID.18**: Patient account number (`ACC123456`)

### PV1 - Patient Visit Segment

```
PV1|1|I|ICU^101^A|||E|||ATTENDING123|REFERRING456||||ADM||||20231215120000
```

**Field Breakdown:**
- **PV1.1**: Set ID (`1`)
- **PV1.2**: Patient class (`I` = Inpatient)
  - `E` = Emergency, `I` = Inpatient, `O` = Outpatient
- **PV1.3**: Assigned patient location (`ICU^101^A`)
  - Format: `DEPARTMENT^ROOM^BED`
- **PV1.4**: Admission type (`E` = Emergency)
  - `E` = Emergency, `R` = Routine, `U` = Urgent
- **PV1.7**: Attending doctor (`ATTENDING123`)
- **PV1.8**: Referring doctor (`REFERRING456`)
- **PV1.10**: Hospital service (`ADM`)
- **PV1.44**: Admit date/time (`20231215120000`)

---

## Field Separators and Encoding

### Standard Encoding Characters

HL7 uses specific characters for message structure:

| Character | Purpose | Example |
|-----------|---------|---------|
| `|` | Field separator | Separates fields within a segment |
| `^` | Component separator | Separates components within a field |
| `~` | Repetition separator | Multiple values in same field |
| `\` | Escape character | Escapes special characters |
| `&` | Sub-component separator | Separates sub-components |

### Example Field Parsing

```
DOE^JOHN^MICHAEL^JR^DR
```
- Component 1: `DOE` (Family name)
- Component 2: `JOHN` (Given name)  
- Component 3: `MICHAEL` (Middle name)
- Component 4: `JR` (Suffix)
- Component 5: `DR` (Prefix)

```
MRN123456^^^VA^MR~123456789^^^USA^SS
```
- First identifier: `MRN123456^^^VA^MR`
- Second identifier: `123456789^^^USA^SS`

---

## Reading ADT Messages

### Manual Parsing Steps

1. **Split message into segments** (by line breaks)
2. **Identify segment type** (first 3 characters)
3. **Split segment into fields** (by `|`)
4. **Split fields into components** (by `^`)
5. **Handle repetitions** (by `~`)

### Example Parsing Logic

```python
def parse_hl7_message(message):
    segments = message.strip().split('\n')
    parsed_message = {}
    
    for segment_line in segments:
        if not segment_line.strip():
            continue
            
        fields = segment_line.split('|')
        segment_type = fields[0]
        
        parsed_message[segment_type] = {}
        
        for i, field in enumerate(fields[1:], 1):
            parsed_message[segment_type][f'field_{i}'] = field
    
    return parsed_message
```

### Common Parsing Patterns

#### Extract Patient Demographics

```python
def extract_patient_demographics(pid_segment):
    fields = pid_segment.split('|')
    
    # Parse patient identifiers (PID.3)
    identifiers = {}
    if len(fields) > 3 and fields[3]:
        id_list = fields[3].split('~')
        for identifier in id_list:
            parts = identifier.split('^')
            if len(parts) >= 5:
                id_value = parts[0]
                authority = parts[3]
                id_type = parts[4]
                identifiers[id_type] = {'value': id_value, 'authority': authority}
    
    # Parse patient name (PID.5)
    name_parts = {'family': '', 'given': '', 'middle': ''}
    if len(fields) > 5 and fields[5]:
        name_components = fields[5].split('^')
        if len(name_components) > 0:
            name_parts['family'] = name_components[0]
        if len(name_components) > 1:
            name_parts['given'] = name_components[1]
        if len(name_components) > 2:
            name_parts['middle'] = name_components[2]
    
    return {
        'identifiers': identifiers,
        'name': name_parts,
        'birth_date': fields[7] if len(fields) > 7 else '',
        'gender': fields[8] if len(fields) > 8 else '',
        'address': fields[11] if len(fields) > 11 else '',
        'phone': fields[13] if len(fields) > 13 else ''
    }
```

---

## Working with ADT Data

### Python Example - Complete ADT Parser

```python
import re
from datetime import datetime

class HL7ADTParser:
    def __init__(self):
        self.field_separator = '|'
        self.component_separator = '^'
        self.repetition_separator = '~'
        
    def parse_message(self, hl7_message):
        lines = hl7_message.strip().split('\n')
        segments = {}
        
        for line in lines:
            if line.strip():
                segment_type = line[:3]
                segments[segment_type] = line
        
        return self.extract_adt_data(segments)
    
    def extract_adt_data(self, segments):
        data = {
            'message_info': self.parse_msh(segments.get('MSH', '')),
            'event_info': self.parse_evn(segments.get('EVN', '')),
            'patient_info': self.parse_pid(segments.get('PID', '')),
            'visit_info': self.parse_pv1(segments.get('PV1', ''))
        }
        return data
    
    def parse_msh(self, msh_segment):
        if not msh_segment:
            return {}
            
        fields = msh_segment.split(self.field_separator)
        return {
            'sending_application': fields[2] if len(fields) > 2 else '',
            'sending_facility': fields[3] if len(fields) > 3 else '',
            'receiving_application': fields[4] if len(fields) > 4 else '',
            'receiving_facility': fields[5] if len(fields) > 5 else '',
            'timestamp': self.parse_timestamp(fields[6] if len(fields) > 6 else ''),
            'message_type': fields[8] if len(fields) > 8 else '',
            'control_id': fields[9] if len(fields) > 9 else '',
            'version': fields[11] if len(fields) > 11 else ''
        }
    
    def parse_pid(self, pid_segment):
        if not pid_segment:
            return {}
            
        fields = pid_segment.split(self.field_separator)
        
        # Parse identifiers
        identifiers = self.parse_identifiers(fields[3] if len(fields) > 3 else '')
        
        # Parse name
        name = self.parse_name(fields[5] if len(fields) > 5 else '')
        
        # Parse address
        address = self.parse_address(fields[11] if len(fields) > 11 else '')
        
        return {
            'identifiers': identifiers,
            'name': name,
            'birth_date': self.parse_date(fields[7] if len(fields) > 7 else ''),
            'gender': fields[8] if len(fields) > 8 else '',
            'race': fields[10] if len(fields) > 10 else '',
            'address': address,
            'phone': fields[13] if len(fields) > 13 else '',
            'language': fields[15] if len(fields) > 15 else '',
            'marital_status': fields[16] if len(fields) > 16 else '',
            'account_number': fields[18] if len(fields) > 18 else ''
        }
    
    def parse_identifiers(self, identifier_field):
        identifiers = {}
        if identifier_field:
            id_list = identifier_field.split(self.repetition_separator)
            for identifier in id_list:
                parts = identifier.split(self.component_separator)
                if len(parts) >= 5:
                    id_type = parts[4]
                    identifiers[id_type] = {
                        'value': parts[0],
                        'authority': parts[3],
                        'type': parts[4]
                    }
        return identifiers
    
    def parse_name(self, name_field):
        name = {'family': '', 'given': '', 'middle': ''}
        if name_field:
            parts = name_field.split(self.component_separator)
            if len(parts) > 0:
                name['family'] = parts[0]
            if len(parts) > 1:
                name['given'] = parts[1]
            if len(parts) > 2:
                name['middle'] = parts[2]
        return name
    
    def parse_address(self, address_field):
        address = {'street': '', 'city': '', 'state': '', 'zip': ''}
        if address_field:
            parts = address_field.split(self.component_separator)
            if len(parts) > 0:
                address['street'] = parts[0]
            if len(parts) > 2:
                address['city'] = parts[2]
            if len(parts) > 3:
                address['state'] = parts[3]
            if len(parts) > 4:
                address['zip'] = parts[4]
        return address
    
    def parse_timestamp(self, timestamp_str):
        if not timestamp_str or len(timestamp_str) < 8:
            return None
        try:
            # HL7 timestamp format: YYYYMMDDHHMMSS
            if len(timestamp_str) >= 14:
                return datetime.strptime(timestamp_str[:14], '%Y%m%d%H%M%S')
            elif len(timestamp_str) >= 8:
                return datetime.strptime(timestamp_str[:8], '%Y%m%d')
        except ValueError:
            return None
        return None
    
    def parse_date(self, date_str):
        if not date_str or len(date_str) < 8:
            return None
        try:
            return datetime.strptime(date_str[:8], '%Y%m%d').date()
        except ValueError:
            return None

# Usage example
parser = HL7ADTParser()

hl7_message = """MSH|^~\&|VistA|VA_FACILITY|Oracle|ORACLE_FACILITY|20231215120000||ADT^A04|MSG001|P|2.5
EVN||20231215120000|||OPERATOR123
PID|1||MRN123456^^^VA^MR~123456789^^^USA^SS||DOE^JOHN^MICHAEL||19800115|M|||123 MAIN ST^^ANYTOWN^VA^12345||555-123-4567||EN|M||ACC123456|||W^White^HL70005
PV1|1|I|ICU^101^A|||E|||ATTENDING123|REFERRING456||||ADM||||20231215120000"""

parsed_data = parser.parse_message(hl7_message)
print("Patient Name:", f"{parsed_data['patient_info']['name']['given']} {parsed_data['patient_info']['name']['family']}")
print("MRN:", parsed_data['patient_info']['identifiers'].get('MR', {}).get('value', 'Unknown'))
print("Message Type:", parsed_data['message_info']['message_type'])
```

### Processing Multiple ADT Messages

```python
def process_adt_file(filename):
    parser = HL7ADTParser()
    patients = []
    
    with open(filename, 'r') as f:
        content = f.read()
    
    # Split messages (assuming messages are separated by blank lines or specific delimiters)
    messages = content.split('\n\n')
    
    for message in messages:
        if message.strip():
            try:
                parsed_data = parser.parse_message(message)
                patients.append(parsed_data)
            except Exception as e:
                print(f"Error parsing message: {e}")
                continue
    
    return patients

# Usage
patients = process_adt_file('hl7_messages_adt.hl7')
print(f"Processed {len(patients)} ADT messages")
```

---

## Tools and Libraries

### Python Libraries

1. **python-hl7**
   ```bash
   pip install hl7
   ```
   
   ```python
   import hl7
   
   # Parse HL7 message
   with open('hl7_messages_adt.hl7', 'r') as f:
       message_text = f.read()
   
   h = hl7.parse(message_text)
   
   # Access segments
   print("Patient name:", h['PID'][5][0])  # PID.5.1
   print("MRN:", h['PID'][3][0][0])        # PID.3.1.1
   ```

2. **hl7apy**
   ```bash
   pip install hl7apy
   ```
   
   ```python
   from hl7apy.parser import parse_message
   
   parsed_msg = parse_message(hl7_message_text)
   
   # Access patient name
   patient_name = parsed_msg.PID.PID_5.PID_5_1.value
   print("Patient Name:", patient_name)
   ```

### Java Libraries

1. **HAPI (HL7 Application Programming Interface)**
   ```xml
   <dependency>
       <groupId>ca.uhn.hapi</groupId>
       <artifactId>hapi-base</artifactId>
       <version>2.3</version>
   </dependency>
   ```

### Online Tools

1. **HL7 Inspector**: Free HL7 message viewer
2. **7Edit**: Commercial HL7 editor and validator
3. **HL7Soup**: Online HL7 message parser

---

## Examples

### Example 1: Extract Patient Registration Data

```python
def extract_registrations(adt_file):
    registrations = []
    parser = HL7ADTParser()
    
    with open(adt_file, 'r') as f:
        content = f.read()
    
    messages = content.strip().split('\n\n')
    
    for message in messages:
        if not message.strip():
            continue
            
        lines = message.strip().split('\n')
        msh_line = next((line for line in lines if line.startswith('MSH')), None)
        
        if msh_line:
            # Check if it's a registration message (A04, A05, A08)
            if any(event in msh_line for event in ['ADT^A04', 'ADT^A05', 'ADT^A08']):
                parsed_data = parser.parse_message(message)
                
                registration = {
                    'event_type': parsed_data['message_info']['message_type'],
                    'patient_name': f"{parsed_data['patient_info']['name']['given']} {parsed_data['patient_info']['name']['family']}",
                    'mrn': parsed_data['patient_info']['identifiers'].get('MR', {}).get('value', ''),
                    'ssn': parsed_data['patient_info']['identifiers'].get('SS', {}).get('value', ''),
                    'birth_date': parsed_data['patient_info']['birth_date'],
                    'registration_time': parsed_data['message_info']['timestamp']
                }
                
                registrations.append(registration)
    
    return registrations

# Usage
registrations = extract_registrations('hl7_messages_adt.hl7')
for reg in registrations:
    print(f"Registration: {reg['patient_name']} (MRN: {reg['mrn']}) - {reg['event_type']}")
```

### Example 2: Track Patient Movements

```python
def track_patient_movements(adt_file):
    movements = []
    parser = HL7ADTParser()
    
    with open(adt_file, 'r') as f:
        content = f.read()
    
    messages = content.strip().split('\n\n')
    
    for message in messages:
        if not message.strip():
            continue
            
        parsed_data = parser.parse_message(message)
        event_type = parsed_data['message_info']['message_type']
        
        # Track admission, transfer, discharge events
        if any(event in event_type for event in ['A01', 'A02', 'A03', 'A06', 'A07']):
            movement = {
                'event_type': event_type,
                'patient_name': f"{parsed_data['patient_info']['name']['given']} {parsed_data['patient_info']['name']['family']}",
                'mrn': parsed_data['patient_info']['identifiers'].get('MR', {}).get('value', ''),
                'location': parsed_data['visit_info'].get('location', ''),
                'patient_class': parsed_data['visit_info'].get('patient_class', ''),
                'event_time': parsed_data['message_info']['timestamp']
            }
            movements.append(movement)
    
    return movements

# Usage and analysis
movements = track_patient_movements('hl7_messages_adt.hl7')

# Group by patient
from collections import defaultdict
patient_movements = defaultdict(list)

for movement in movements:
    mrn = movement['mrn']
    patient_movements[mrn].append(movement)

# Print patient journey
for mrn, patient_events in patient_movements.items():
    patient_events.sort(key=lambda x: x['event_time'] if x['event_time'] else datetime.min)
    print(f"\nPatient {mrn} Journey:")
    for event in patient_events:
        print(f"  {event['event_type']}: {event['location']} at {event['event_time']}")
```

### Example 3: Convert ADT to CSV

```python
import csv
from datetime import datetime

def adt_to_csv(adt_file, output_csv):
    parser = HL7ADTParser()
    
    with open(adt_file, 'r') as f:
        content = f.read()
    
    messages = content.strip().split('\n\n')
    csv_data = []
    
    for message in messages:
        if not message.strip():
            continue
            
        try:
            parsed_data = parser.parse_message(message)
            
            row = {
                'event_type': parsed_data['message_info']['message_type'],
                'control_id': parsed_data['message_info']['control_id'],
                'event_timestamp': parsed_data['message_info']['timestamp'],
                'patient_mrn': parsed_data['patient_info']['identifiers'].get('MR', {}).get('value', ''),
                'patient_ssn': parsed_data['patient_info']['identifiers'].get('SS', {}).get('value', ''),
                'patient_first_name': parsed_data['patient_info']['name']['given'],
                'patient_last_name': parsed_data['patient_info']['name']['family'],
                'patient_middle_name': parsed_data['patient_info']['name']['middle'],
                'birth_date': parsed_data['patient_info']['birth_date'],
                'gender': parsed_data['patient_info']['gender'],
                'race': parsed_data['patient_info']['race'],
                'address_street': parsed_data['patient_info']['address']['street'],
                'address_city': parsed_data['patient_info']['address']['city'],
                'address_state': parsed_data['patient_info']['address']['state'],
                'address_zip': parsed_data['patient_info']['address']['zip'],
                'phone': parsed_data['patient_info']['phone'],
                'language': parsed_data['patient_info']['language'],
                'marital_status': parsed_data['patient_info']['marital_status'],
                'account_number': parsed_data['patient_info']['account_number']
            }
            
            csv_data.append(row)
            
        except Exception as e:
            print(f"Error processing message: {e}")
            continue
    
    # Write to CSV
    if csv_data:
        with open(output_csv, 'w', newline='', encoding='utf-8') as csvfile:
            fieldnames = csv_data[0].keys()
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            writer.writerows(csv_data)
        
        print(f"Exported {len(csv_data)} ADT messages to {output_csv}")

# Usage
adt_to_csv('hl7_messages_adt.hl7', 'adt_data.csv')
```

---

## Best Practices

### Reading ADT Messages
1. **Always validate message structure** before parsing
2. **Handle missing segments gracefully** - not all ADT messages contain all segments
3. **Parse encoding characters from MSH.2** - don't assume standard encoding
4. **Check for message continuation** - some messages span multiple lines

### Error Handling
```python
def safe_parse_adt(message_text):
    try:
        parser = HL7ADTParser()
        return parser.parse_message(message_text)
    except Exception as e:
        print(f"Error parsing ADT message: {e}")
        return None
```

### Performance Considerations
- **Use generators** for processing large files
- **Index messages by control ID** for faster lookups  
- **Cache parsed results** if processing the same messages repeatedly

This comprehensive primer provides everything needed to understand and work with HL7 ADT messages effectively.