# HL7 ORU Messages Primer: Understanding Observation Result Messages

## Overview

HL7 ORU (Observation Result Unsolicited) messages communicate laboratory results, diagnostic reports, and clinical observations between healthcare systems. This primer explains how to read, understand, and work with HL7 ORU messages generated by the Synthetic Healthcare Data Generator.

## Table of Contents

1. [What are HL7 ORU Messages?](#what-are-hl7-oru-messages)
2. [Message Structure](#message-structure)
3. [ORU Event Types](#oru-event-types)
4. [Segment Breakdown](#segment-breakdown)
5. [Observation Hierarchies](#observation-hierarchies)
6. [Reading ORU Messages](#reading-oru-messages)
7. [Working with Lab Results](#working-with-lab-results)
8. [Tools and Libraries](#tools-and-libraries)
9. [Examples](#examples)

---

## What are HL7 ORU Messages?

**HL7 ORU (Observation Result Unsolicited)** messages are used to transmit clinical observations and laboratory results from diagnostic systems to clinical information systems. They handle:

- **Laboratory Results** (Chemistry, Hematology, Microbiology)
- **Diagnostic Reports** (Radiology, Pathology)
- **Vital Signs** (Blood Pressure, Temperature, Heart Rate)
- **Clinical Observations** (Physical exam findings, assessments)

### Key Use Cases
- **Lab Information Systems (LIS)**: Send lab results to EHR systems
- **Radiology Systems**: Transmit diagnostic reports
- **Point-of-Care Devices**: Send vital signs and bedside test results
- **Clinical Decision Support**: Provide data for alerts and recommendations

### Common ORU Scenarios
- Lab completes blood test → sends ORU^R01 to EHR
- Radiology reads X-ray → sends ORU^R01 with diagnostic report
- ICU monitor captures vital signs → sends ORU^R01 continuously

---

## Message Structure

### Basic ORU Message Format

```
MSH|^~\&|LAB_SYSTEM|HOSPITAL_LAB|EHR_SYSTEM|HOSPITAL|TIMESTAMP||ORU^R01|CONTROL_ID|P|2.5
PID|1||MRN^^^HOSPITAL^MR||LAST^FIRST^MIDDLE||DOB|SEX
OBR|1|ORDER_NUM||LOINC_CODE^TEST_NAME^LOINC|||OBSERVATION_TIME|||||||||PROVIDER|||RESULT_STATUS|||
OBX|1|NM|LOINC_CODE^GLUCOSE^LOINC|1|85|mg/dL|70-110|N|||F
OBX|2|NM|LOINC_CODE^HEMOGLOBIN^LOINC|2|12.5|g/dL|12-16|N|||F
```

### Message Components
- **MSH**: Message Header (required)
- **PID**: Patient Identification (required)
- **OBR**: Observation Request (required - can have multiple)
- **OBX**: Observation Result (required - can have multiple per OBR)
- **NTE**: Notes and Comments (optional)

---

## ORU Event Types

### Primary ORU Events

| Event Code | Description | When Used |
|------------|-------------|-----------|
| **R01** | Unsolicited transmission of observation message | Standard lab/diagnostic results |
| **R02** | Query for results of observation | Request for specific test results |
| **R03** | Display response to query | Response to R02 query |
| **R04** | Response to query; transmission of requested observation | Complete response with results |

### Result Status Codes

| Status | Description | Meaning |
|--------|-------------|---------|
| **F** | Final | Results are complete and verified |
| **P** | Preliminary | Initial results, may change |
| **C** | Corrected | Correction to previously sent results |
| **X** | Cannot obtain results | Test could not be completed |
| **I** | In process | Test is in progress |

---

## Segment Breakdown

### MSH - Message Header Segment

```
MSH|^~\&|LAB_SYSTEM|HOSPITAL_LAB|EHR_SYSTEM|HOSPITAL|20231215143000||ORU^R01|MSG002|P|2.5
```

Similar to ADT messages, with **MSH.9** indicating message type `ORU^R01`.

### PID - Patient Identification Segment

```
PID|1||MRN123456^^^HOSPITAL^MR||DOE^JOHN^MICHAEL||19800115|M
```

Patient demographics - same structure as ADT messages.

### OBR - Observation Request Segment

The OBR segment identifies the test/procedure that was performed:

```
OBR|1|ORDER12345|ACCESSION67890|1558-6^FASTING GLUCOSE^LN|||20231215140000|||||||||ORDERING_PROVIDER|||F|||
```

**Field Breakdown:**
- **OBR.1**: Set ID (`1`)
- **OBR.2**: Placer order number (`ORDER12345`)
- **OBR.3**: Filler order number (`ACCESSION67890`)
- **OBR.4**: Universal service identifier (`1558-6^FASTING GLUCOSE^LN`)
  - LOINC code for the test ordered
- **OBR.7**: Observation date/time (`20231215140000`)
- **OBR.16**: Ordering provider
- **OBR.25**: Result status (`F` = Final)

### OBX - Observation Result Segment

The OBX segment contains the actual test results:

```
OBX|1|NM|1558-6^FASTING GLUCOSE^LN|1|85|mg/dL|70-110|N|||F
```

**Field Breakdown:**
- **OBX.1**: Set ID (`1`)
- **OBX.2**: Value type (`NM` = Numeric)
- **OBX.3**: Observation identifier (`1558-6^FASTING GLUCOSE^LN`)
- **OBX.4**: Observation sub-ID (`1`)
- **OBX.5**: Observation value (`85`)
- **OBX.6**: Units (`mg/dL`)
- **OBX.7**: Reference range (`70-110`)
- **OBX.8**: Abnormal flags (`N` = Normal)
- **OBX.11**: Observation result status (`F` = Final)

### Value Types in OBX.2

| Code | Description | Example Value |
|------|-------------|---------------|
| **NM** | Numeric | `85` |
| **ST** | String | `NEGATIVE` |
| **TX** | Text | `Large paragraph of text` |
| **CE** | Coded Entry | `POS^POSITIVE^LOCAL` |
| **DT** | Date | `20231215` |
| **TM** | Time | `143000` |
| **TS** | Timestamp | `20231215143000` |

### Abnormal Flags (OBX.8)

| Flag | Meaning | Description |
|------|---------|-------------|
| **N** | Normal | Within reference range |
| **H** | High | Above reference range |
| **L** | Low | Below reference range |
| **HH** | Critical High | Critically high value |
| **LL** | Critical Low | Critically low value |
| **A** | Abnormal | Abnormal (non-numeric) |

---

## Observation Hierarchies

ORU messages can represent complex hierarchical relationships:

### Simple Lab Panel

```
OBR|1|||CHEM7^BASIC METABOLIC PANEL^LOCAL|||20231215140000
OBX|1|NM|2345-7^GLUCOSE^LN|1|85|mg/dL|70-110|N|||F
OBX|2|NM|2951-2^SODIUM^LN|2|140|mmol/L|136-145|N|||F
OBX|3|NM|2823-3^POTASSIUM^LN|3|4.0|mmol/L|3.5-5.1|N|||F
```

### Complex Microbiology Results

```
OBR|1|||87088^CULTURE, BACTERIAL^CPT|||20231215140000
OBX|1|CE|87088^ORGANISM^LOCAL|1|ECO^E. COLI^LOCAL||||A|||F
OBX|2|ST|87184^SENSITIVITY^LOCAL|1.1|AMPICILLIN||||S|||F
OBX|3|ST|87184^SENSITIVITY^LOCAL|1.2|CIPROFLOXACIN||||S|||F
OBX|4|ST|87184^SENSITIVITY^LOCAL|1.3|TRIMETHOPRIM||||R|||F
```

### Radiology Report

```
OBR|1|||36572-8^CT CHEST W CONTRAST^LN|||20231215140000
OBX|1|TX|36572-8^IMPRESSION^LOCAL|1|No acute findings. Normal chest CT.||||N|||F
OBX|2|TX|36572-8^FINDINGS^LOCAL|2|Heart size normal. Lungs clear bilaterally.||||N|||F
```

---

## Reading ORU Messages

### Python ORU Parser

```python
import re
from datetime import datetime
from typing import List, Dict, Any

class HL7ORUParser:
    def __init__(self):
        self.field_separator = '|'
        self.component_separator = '^'
        self.repetition_separator = '~'
    
    def parse_message(self, hl7_message: str) -> Dict[str, Any]:
        lines = hl7_message.strip().split('\n')
        segments = {}
        
        # Group segments
        current_obr = None
        obr_segments = []
        obx_segments = []
        
        for line in lines:
            if not line.strip():
                continue
                
            segment_type = line[:3]
            
            if segment_type == 'MSH':
                segments['MSH'] = line
            elif segment_type == 'PID':
                segments['PID'] = line
            elif segment_type == 'OBR':
                if current_obr:
                    # Save previous OBR group
                    obr_segments.append({
                        'OBR': current_obr,
                        'OBX': obx_segments.copy()
                    })
                    obx_segments.clear()
                current_obr = line
            elif segment_type == 'OBX':
                obx_segments.append(line)
        
        # Add the last OBR group
        if current_obr:
            obr_segments.append({
                'OBR': current_obr,
                'OBX': obx_segments
            })
        
        return {
            'message_header': self.parse_msh(segments.get('MSH', '')),
            'patient_info': self.parse_pid(segments.get('PID', '')),
            'observations': [self.parse_obr_group(group) for group in obr_segments]
        }
    
    def parse_obr_group(self, obr_group: Dict) -> Dict[str, Any]:
        obr_data = self.parse_obr(obr_group['OBR'])
        obx_data = [self.parse_obx(obx) for obx in obr_group['OBX']]
        
        return {
            'order_info': obr_data,
            'results': obx_data
        }
    
    def parse_obr(self, obr_segment: str) -> Dict[str, Any]:
        if not obr_segment:
            return {}
            
        fields = obr_segment.split(self.field_separator)
        
        # Parse universal service identifier (OBR.4)
        service_id = self.parse_coded_element(fields[4] if len(fields) > 4 else '')
        
        return {
            'set_id': fields[1] if len(fields) > 1 else '',
            'placer_order_number': fields[2] if len(fields) > 2 else '',
            'filler_order_number': fields[3] if len(fields) > 3 else '',
            'service_identifier': service_id,
            'observation_datetime': self.parse_timestamp(fields[7] if len(fields) > 7 else ''),
            'ordering_provider': fields[16] if len(fields) > 16 else '',
            'result_status': fields[25] if len(fields) > 25 else ''
        }
    
    def parse_obx(self, obx_segment: str) -> Dict[str, Any]:
        if not obx_segment:
            return {}
            
        fields = obx_segment.split(self.field_separator)
        
        # Parse observation identifier (OBX.3)
        observation_id = self.parse_coded_element(fields[3] if len(fields) > 3 else '')
        
        # Parse observation value based on value type
        value_type = fields[2] if len(fields) > 2 else ''
        raw_value = fields[5] if len(fields) > 5 else ''
        parsed_value = self.parse_observation_value(raw_value, value_type)
        
        return {
            'set_id': fields[1] if len(fields) > 1 else '',
            'value_type': value_type,
            'observation_identifier': observation_id,
            'sub_id': fields[4] if len(fields) > 4 else '',
            'observation_value': parsed_value,
            'units': fields[6] if len(fields) > 6 else '',
            'reference_range': fields[7] if len(fields) > 7 else '',
            'abnormal_flags': fields[8] if len(fields) > 8 else '',
            'result_status': fields[11] if len(fields) > 11 else ''
        }
    
    def parse_coded_element(self, coded_field: str) -> Dict[str, str]:
        if not coded_field:
            return {}
            
        parts = coded_field.split(self.component_separator)
        return {
            'code': parts[0] if len(parts) > 0 else '',
            'text': parts[1] if len(parts) > 1 else '',
            'coding_system': parts[2] if len(parts) > 2 else ''
        }
    
    def parse_observation_value(self, value: str, value_type: str) -> Any:
        if not value:
            return None
            
        if value_type == 'NM':  # Numeric
            try:
                if '.' in value:
                    return float(value)
                return int(value)
            except ValueError:
                return value
        elif value_type == 'CE':  # Coded Entry
            return self.parse_coded_element(value)
        elif value_type in ['ST', 'TX']:  # String/Text
            return value
        elif value_type == 'DT':  # Date
            return self.parse_date(value)
        elif value_type == 'TS':  # Timestamp
            return self.parse_timestamp(value)
        else:
            return value
    
    def parse_timestamp(self, timestamp_str: str) -> datetime:
        if not timestamp_str or len(timestamp_str) < 8:
            return None
        try:
            if len(timestamp_str) >= 14:
                return datetime.strptime(timestamp_str[:14], '%Y%m%d%H%M%S')
            elif len(timestamp_str) >= 8:
                return datetime.strptime(timestamp_str[:8], '%Y%m%d')
        except ValueError:
            return None
        return None
    
    def parse_date(self, date_str: str) -> datetime:
        if not date_str or len(date_str) < 8:
            return None
        try:
            return datetime.strptime(date_str[:8], '%Y%m%d').date()
        except ValueError:
            return None
    
    def parse_msh(self, msh_segment: str) -> Dict[str, Any]:
        if not msh_segment:
            return {}
            
        fields = msh_segment.split(self.field_separator)
        return {
            'sending_application': fields[2] if len(fields) > 2 else '',
            'sending_facility': fields[3] if len(fields) > 3 else '',
            'receiving_application': fields[4] if len(fields) > 4 else '',
            'receiving_facility': fields[5] if len(fields) > 5 else '',
            'timestamp': self.parse_timestamp(fields[6] if len(fields) > 6 else ''),
            'message_type': fields[8] if len(fields) > 8 else '',
            'control_id': fields[9] if len(fields) > 9 else ''
        }
    
    def parse_pid(self, pid_segment: str) -> Dict[str, Any]:
        # Reuse PID parsing from ADT parser (same structure)
        if not pid_segment:
            return {}
            
        fields = pid_segment.split(self.field_separator)
        
        # Parse identifiers
        identifiers = self.parse_identifiers(fields[3] if len(fields) > 3 else '')
        
        # Parse name
        name = self.parse_name(fields[5] if len(fields) > 5 else '')
        
        return {
            'identifiers': identifiers,
            'name': name,
            'birth_date': self.parse_date(fields[7] if len(fields) > 7 else ''),
            'gender': fields[8] if len(fields) > 8 else ''
        }
    
    def parse_identifiers(self, identifier_field: str) -> Dict[str, Dict]:
        identifiers = {}
        if identifier_field:
            id_list = identifier_field.split(self.repetition_separator)
            for identifier in id_list:
                parts = identifier.split(self.component_separator)
                if len(parts) >= 5:
                    id_type = parts[4]
                    identifiers[id_type] = {
                        'value': parts[0],
                        'authority': parts[3]
                    }
        return identifiers
    
    def parse_name(self, name_field: str) -> Dict[str, str]:
        name = {'family': '', 'given': '', 'middle': ''}
        if name_field:
            parts = name_field.split(self.component_separator)
            if len(parts) > 0:
                name['family'] = parts[0]
            if len(parts) > 1:
                name['given'] = parts[1]
            if len(parts) > 2:
                name['middle'] = parts[2]
        return name

# Usage Example
parser = HL7ORUParser()

oru_message = """MSH|^~\&|LAB_SYS|HOSPITAL_LAB|EHR_SYS|HOSPITAL|20231215143000||ORU^R01|MSG002|P|2.5
PID|1||MRN123456^^^HOSPITAL^MR||DOE^JOHN^MICHAEL||19800115|M
OBR|1|ORDER12345||1558-6^FASTING GLUCOSE^LN|||20231215140000|||||||||DR_SMITH|||F|||
OBX|1|NM|1558-6^FASTING GLUCOSE^LN|1|95|mg/dL|70-110|H|||F
OBX|2|ST|1558-6^GLUCOSE COMMENT^LN|2|Slightly elevated, recommend repeat|||A|||F"""

parsed_data = parser.parse_message(oru_message)

# Display results
print("Patient:", f"{parsed_data['patient_info']['name']['given']} {parsed_data['patient_info']['name']['family']}")
for observation in parsed_data['observations']:
    test_name = observation['order_info']['service_identifier']['text']
    print(f"\nTest: {test_name}")
    for result in observation['results']:
        obs_name = result['observation_identifier']['text']
        value = result['observation_value']
        units = result['units']
        flag = result['abnormal_flags']
        print(f"  {obs_name}: {value} {units} ({flag})")
```

---

## Working with Lab Results

### Analyzing Lab Values

```python
def analyze_lab_results(oru_file: str) -> Dict[str, Any]:
    parser = HL7ORUParser()
    
    with open(oru_file, 'r') as f:
        content = f.read()
    
    # Split messages
    messages = content.strip().split('\n\n')
    
    analysis = {
        'total_patients': set(),
        'total_tests': 0,
        'abnormal_results': 0,
        'test_frequency': {},
        'abnormal_flags': {'H': 0, 'L': 0, 'HH': 0, 'LL': 0, 'A': 0},
        'common_tests': []
    }
    
    for message in messages:
        if not message.strip():
            continue
            
        try:
            parsed_data = parser.parse_message(message)
            
            # Track patient
            mrn = parsed_data['patient_info']['identifiers'].get('MR', {}).get('value', '')
            if mrn:
                analysis['total_patients'].add(mrn)
            
            # Analyze observations
            for observation in parsed_data['observations']:
                test_name = observation['order_info']['service_identifier']['text']
                
                # Count tests
                analysis['test_frequency'][test_name] = analysis['test_frequency'].get(test_name, 0) + 1
                
                for result in observation['results']:
                    analysis['total_tests'] += 1
                    
                    # Check for abnormal flags
                    flag = result['abnormal_flags']
                    if flag and flag in analysis['abnormal_flags']:
                        analysis['abnormal_flags'][flag] += 1
                        analysis['abnormal_results'] += 1
                        
        except Exception as e:
            print(f"Error processing message: {e}")
            continue
    
    # Convert set to count
    analysis['total_patients'] = len(analysis['total_patients'])
    
    # Get most common tests
    analysis['common_tests'] = sorted(
        analysis['test_frequency'].items(), 
        key=lambda x: x[1], 
        reverse=True
    )[:10]
    
    return analysis

# Usage
analysis = analyze_lab_results('hl7_messages_oru.hl7')
print(f"Total patients with lab results: {analysis['total_patients']}")
print(f"Total test results: {analysis['total_tests']}")
print(f"Abnormal results: {analysis['abnormal_results']} ({analysis['abnormal_results']/analysis['total_tests']*100:.1f}%)")
print("\nMost common tests:")
for test, count in analysis['common_tests']:
    print(f"  {test}: {count}")
```

### Extract Critical Values

```python
def find_critical_values(oru_file: str) -> List[Dict]:
    parser = HL7ORUParser()
    critical_values = []
    
    # Define critical value ranges
    critical_ranges = {
        'GLUCOSE': {'low': 50, 'high': 400},
        'SODIUM': {'low': 120, 'high': 160},
        'POTASSIUM': {'low': 2.5, 'high': 6.5},
        'HEMOGLOBIN': {'low': 6.0, 'high': 20.0},
        'CREATININE': {'low': 0.1, 'high': 10.0}
    }
    
    with open(oru_file, 'r') as f:
        content = f.read()
    
    messages = content.strip().split('\n\n')
    
    for message in messages:
        if not message.strip():
            continue
            
        try:
            parsed_data = parser.parse_message(message)
            
            patient_info = parsed_data['patient_info']
            mrn = patient_info['identifiers'].get('MR', {}).get('value', 'Unknown')
            patient_name = f"{patient_info['name']['given']} {patient_info['name']['family']}"
            
            for observation in parsed_data['observations']:
                for result in observation['results']:
                    test_name = result['observation_identifier']['text'].upper()
                    value = result['observation_value']
                    flag = result['abnormal_flags']
                    
                    # Check for critical flags
                    if flag in ['HH', 'LL']:
                        critical_values.append({
                            'patient_mrn': mrn,
                            'patient_name': patient_name,
                            'test_name': test_name,
                            'value': value,
                            'units': result['units'],
                            'flag': flag,
                            'reference_range': result['reference_range'],
                            'timestamp': parsed_data['message_header']['timestamp']
                        })
                    
                    # Check against defined critical ranges
                    elif isinstance(value, (int, float)):
                        for critical_test, ranges in critical_ranges.items():
                            if critical_test in test_name:
                                if value <= ranges['low'] or value >= ranges['high']:
                                    critical_values.append({
                                        'patient_mrn': mrn,
                                        'patient_name': patient_name,
                                        'test_name': test_name,
                                        'value': value,
                                        'units': result['units'],
                                        'flag': 'CRITICAL_VALUE',
                                        'reference_range': result['reference_range'],
                                        'timestamp': parsed_data['message_header']['timestamp']
                                    })
                                break
                        
        except Exception as e:
            print(f"Error processing message: {e}")
            continue
    
    return critical_values

# Usage
critical_values = find_critical_values('hl7_messages_oru.hl7')
print(f"Found {len(critical_values)} critical values:")
for cv in critical_values:
    print(f"  {cv['patient_name']} ({cv['patient_mrn']}): {cv['test_name']} = {cv['value']} {cv['units']} [{cv['flag']}]")
```

### Convert ORU to Lab Database

```python
import sqlite3
from typing import List

def create_lab_database(oru_file: str, db_file: str):
    # Create SQLite database
    conn = sqlite3.connect(db_file)
    cursor = conn.cursor()
    
    # Create tables
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS patients (
            mrn TEXT PRIMARY KEY,
            first_name TEXT,
            last_name TEXT,
            birth_date TEXT,
            gender TEXT
        )
    ''')
    
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS lab_orders (
            order_id TEXT PRIMARY KEY,
            patient_mrn TEXT,
            test_name TEXT,
            order_datetime TEXT,
            ordering_provider TEXT,
            result_status TEXT,
            FOREIGN KEY (patient_mrn) REFERENCES patients (mrn)
        )
    ''')
    
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS lab_results (
            result_id INTEGER PRIMARY KEY AUTOINCREMENT,
            order_id TEXT,
            test_name TEXT,
            loinc_code TEXT,
            result_value TEXT,
            value_type TEXT,
            units TEXT,
            reference_range TEXT,
            abnormal_flag TEXT,
            result_status TEXT,
            FOREIGN KEY (order_id) REFERENCES lab_orders (order_id)
        )
    ''')
    
    # Parse ORU messages and insert data
    parser = HL7ORUParser()
    
    with open(oru_file, 'r') as f:
        content = f.read()
    
    messages = content.strip().split('\n\n')
    
    for message in messages:
        if not message.strip():
            continue
            
        try:
            parsed_data = parser.parse_message(message)
            
            # Insert patient data
            patient_info = parsed_data['patient_info']
            mrn = patient_info['identifiers'].get('MR', {}).get('value', '')
            if mrn:
                cursor.execute('''
                    INSERT OR REPLACE INTO patients 
                    (mrn, first_name, last_name, birth_date, gender)
                    VALUES (?, ?, ?, ?, ?)
                ''', (
                    mrn,
                    patient_info['name']['given'],
                    patient_info['name']['family'],
                    str(patient_info['birth_date']) if patient_info['birth_date'] else '',
                    patient_info['gender']
                ))
            
            # Insert lab orders and results
            for observation in parsed_data['observations']:
                order_info = observation['order_info']
                order_id = order_info['filler_order_number'] or order_info['placer_order_number']
                
                if order_id:
                    cursor.execute('''
                        INSERT OR REPLACE INTO lab_orders
                        (order_id, patient_mrn, test_name, order_datetime, ordering_provider, result_status)
                        VALUES (?, ?, ?, ?, ?, ?)
                    ''', (
                        order_id,
                        mrn,
                        order_info['service_identifier']['text'],
                        str(order_info['observation_datetime']) if order_info['observation_datetime'] else '',
                        order_info['ordering_provider'],
                        order_info['result_status']
                    ))
                
                # Insert individual results
                for result in observation['results']:
                    cursor.execute('''
                        INSERT INTO lab_results
                        (order_id, test_name, loinc_code, result_value, value_type, units, reference_range, abnormal_flag, result_status)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        order_id,
                        result['observation_identifier']['text'],
                        result['observation_identifier']['code'],
                        str(result['observation_value']),
                        result['value_type'],
                        result['units'],
                        result['reference_range'],
                        result['abnormal_flags'],
                        result['result_status']
                    ))
                    
        except Exception as e:
            print(f"Error processing message: {e}")
            continue
    
    conn.commit()
    conn.close()
    
    print(f"Lab database created: {db_file}")

# Usage
create_lab_database('hl7_messages_oru.hl7', 'lab_results.db')

# Query the database
conn = sqlite3.connect('lab_results.db')
cursor = conn.cursor()

# Get abnormal results
cursor.execute('''
    SELECT p.first_name, p.last_name, lr.test_name, lr.result_value, lr.units, lr.abnormal_flag
    FROM lab_results lr
    JOIN lab_orders lo ON lr.order_id = lo.order_id
    JOIN patients p ON lo.patient_mrn = p.mrn
    WHERE lr.abnormal_flag IN ('H', 'L', 'HH', 'LL', 'A')
    ORDER BY lr.abnormal_flag DESC
''')

abnormal_results = cursor.fetchall()
print(f"\nFound {len(abnormal_results)} abnormal results:")
for result in abnormal_results[:10]:  # Show first 10
    print(f"  {result[0]} {result[1]}: {result[2]} = {result[3]} {result[4]} [{result[5]}]")

conn.close()
```

---

## Tools and Libraries

### Python Libraries

1. **python-hl7**
   ```python
   import hl7
   
   # Parse ORU message
   h = hl7.parse(oru_message)
   
   # Access OBX segments
   for obx in h.segment('OBX'):
       test_name = obx[3][1]  # OBX.3.2
       value = obx[5]         # OBX.5
       units = obx[6]         # OBX.6
       print(f"{test_name}: {value} {units}")
   ```

2. **hl7apy**
   ```python
   from hl7apy.parser import parse_message
   
   parsed_msg = parse_message(oru_message)
   
   # Access results
   for obx in parsed_msg.children:
       if obx.name == 'OBX':
           test_name = obx.obx_3.obx_3_2.value
           result_value = obx.obx_5.value
           print(f"{test_name}: {result_value}")
   ```

### Database Integration

```python
# PostgreSQL example
import psycopg2

def store_lab_results_postgres(parsed_data, conn):
    cursor = conn.cursor()
    
    for observation in parsed_data['observations']:
        for result in observation['results']:
            cursor.execute("""
                INSERT INTO lab_results 
                (patient_mrn, test_code, test_name, result_value, units, reference_range, abnormal_flag)
                VALUES (%s, %s, %s, %s, %s, %s, %s)
            """, (
                parsed_data['patient_info']['identifiers']['MR']['value'],
                result['observation_identifier']['code'],
                result['observation_identifier']['text'],
                result['observation_value'],
                result['units'],
                result['reference_range'],
                result['abnormal_flags']
            ))
    
    conn.commit()
```

---

## Examples

### Example 1: Lab Report Generator

```python
def generate_lab_report(oru_file: str, patient_mrn: str) -> str:
    parser = HL7ORUParser()
    
    with open(oru_file, 'r') as f:
        content = f.read()
    
    messages = content.strip().split('\n\n')
    patient_results = []
    
    for message in messages:
        if not message.strip():
            continue
            
        try:
            parsed_data = parser.parse_message(message)
            
            # Check if this is the correct patient
            mrn = parsed_data['patient_info']['identifiers'].get('MR', {}).get('value', '')
            if mrn == patient_mrn:
                patient_results.append(parsed_data)
                
        except Exception as e:
            continue
    
    if not patient_results:
        return f"No lab results found for patient MRN: {patient_mrn}"
    
    # Generate report
    patient_info = patient_results[0]['patient_info']
    report = f"""
LABORATORY REPORT
=================

Patient: {patient_info['name']['given']} {patient_info['name']['family']}
MRN: {patient_mrn}
DOB: {patient_info['birth_date']}
Gender: {patient_info['gender']}

RESULTS:
--------
"""
    
    for result_data in patient_results:
        timestamp = result_data['message_header']['timestamp']
        report += f"\nDate: {timestamp}\n"
        
        for observation in result_data['observations']:
            test_name = observation['order_info']['service_identifier']['text']
            report += f"\n{test_name}:\n"
            
            for result in observation['results']:
                obs_name = result['observation_identifier']['text']
                value = result['observation_value']
                units = result['units']
                ref_range = result['reference_range']
                flag = result['abnormal_flags']
                
                flag_text = f" [{flag}]" if flag and flag != 'N' else ""
                report += f"  {obs_name}: {value} {units} (Ref: {ref_range}){flag_text}\n"
    
    return report

# Usage
report = generate_lab_report('hl7_messages_oru.hl7', 'MRN123456')
print(report)
```

### Example 2: Quality Control Dashboard

```python
def lab_quality_control(oru_file: str) -> Dict[str, Any]:
    parser = HL7ORUParser()
    
    with open(oru_file, 'r') as f:
        content = f.read()
    
    messages = content.strip().split('\n\n')
    
    qc_stats = {
        'total_messages': len(messages),
        'successful_parses': 0,
        'failed_parses': 0,
        'missing_patient_id': 0,
        'missing_results': 0,
        'preliminary_results': 0,
        'final_results': 0,
        'corrected_results': 0,
        'turnaround_times': [],
        'test_volumes': {}
    }
    
    for message in messages:
        if not message.strip():
            continue
            
        try:
            parsed_data = parser.parse_message(message)
            qc_stats['successful_parses'] += 1
            
            # Check for missing patient ID
            mrn = parsed_data['patient_info']['identifiers'].get('MR', {}).get('value', '')
            if not mrn:
                qc_stats['missing_patient_id'] += 1
            
            # Check observations
            if not parsed_data['observations']:
                qc_stats['missing_results'] += 1
                continue
            
            for observation in parsed_data['observations']:
                # Count result statuses
                status = observation['order_info']['result_status']
                if status == 'P':
                    qc_stats['preliminary_results'] += 1
                elif status == 'F':
                    qc_stats['final_results'] += 1
                elif status == 'C':
                    qc_stats['corrected_results'] += 1
                
                # Count test volumes
                test_name = observation['order_info']['service_identifier']['text']
                qc_stats['test_volumes'][test_name] = qc_stats['test_volumes'].get(test_name, 0) + 1
                
        except Exception as e:
            qc_stats['failed_parses'] += 1
    
    # Calculate percentages
    total = qc_stats['successful_parses']
    if total > 0:
        qc_stats['success_rate'] = qc_stats['successful_parses'] / qc_stats['total_messages'] * 100
        qc_stats['missing_id_rate'] = qc_stats['missing_patient_id'] / total * 100
        qc_stats['preliminary_rate'] = qc_stats['preliminary_results'] / total * 100
    
    return qc_stats

# Usage
qc_report = lab_quality_control('hl7_messages_oru.hl7')
print(f"Message Success Rate: {qc_report['success_rate']:.1f}%")
print(f"Missing Patient ID Rate: {qc_report['missing_id_rate']:.1f}%")
print(f"Preliminary Results: {qc_report['preliminary_results']}")
print(f"Final Results: {qc_report['final_results']}")
```

---

## Best Practices

### Reading ORU Messages
1. **Group OBR and OBX segments properly** - each OBR can have multiple OBX
2. **Handle different value types** - numeric, text, coded values
3. **Check result status** - don't assume all results are final
4. **Parse LOINC codes** for standardized test identification

### Performance Optimization
```python
# Use generators for large files
def parse_oru_stream(filename):
    with open(filename, 'r') as f:
        current_message = []
        for line in f:
            if line.strip():
                current_message.append(line.strip())
            else:
                if current_message:
                    yield '\n'.join(current_message)
                    current_message = []
        
        # Yield last message
        if current_message:
            yield '\n'.join(current_message)
```

### Error Handling
```python
def safe_parse_numeric_result(value_str):
    try:
        if '.' in value_str:
            return float(value_str)
        return int(value_str)
    except (ValueError, TypeError):
        return value_str  # Return as string if not numeric
```

This primer provides comprehensive guidance for understanding and working with HL7 ORU messages for laboratory and diagnostic results.